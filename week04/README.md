# Седмица 04 
## Какво правихме предният път
## Днес ще работим с динамична памет
[www.tutorialspoint.com/cplusplus/cpp_dynamic_memory](https://www.tutorialspoint.com/cplusplus/cpp_dynamic_memory.htm)
## Динамична памет
Хмм.. За разлика от повечето езици за програмиране, С++ добавя още малко интересни неща свързани с директния достъп до паметта (освен указателите). В C++ паметта, с която вашата програма работи се разделя на **2 части:**
* Stack - паметта, която се заделя и освобождава автоматично за всички променливи във всички функции на програмата + стековите рамки на функциите.
* Heap - паметта, която не се изпозва от програмата, докато ние **РЪЧНО** не я заделим и освободим, по време на изпълнението на програмата.

[Stack & Heap](https://www.geeksforgeeks.org/memory-layout-of-c-program/)
### Важно: При динамично заделената памет, програмистът отговаря за нейното заделяне(когато му е необходима) и освобождаване(когато вече не му е неонходима). Ако не освободи паметта, ще се получи MEMORY LEAK - изтичане на памет(последвано обикновено от СИН екран :Д).

### Заделяне и освобождаване на динамична памет
С++ поддържа два оператора за манипулиране на динамичната памет: **new** - за заделяне и **delete** - за освобождаване. 

#### NEW
```c++
pointer-variable = new data-type;

int *ptr = new int(25);

int *ptr2 = new int[10];
```
**Ако няма достатъчно памет, която искаме да заделим, тогава се връща "грешка" от тип std::bad_alloc или NULL указател.**

#### DELETE
```c++
delete pointer-variable; 

delete ptr;

delete[] ptr2;
```
**Не забравяйте []! иначе няма да освободи и 10-те клетки.**

## Файлови потоци
### Създаване на файлов поток и отваряне на файл
* Използваме библиотеката `fstream`
* `fstream myFileStream;` - създаване на файлов поток
* `myFileStream.open("myFile.txt");` - отваряне на файл
* `fstream myFileStream("myFile.txt")` - създава файлов поток и отваря файл (комбинира горните две точки)
* `ifstream fi("fileName")` - отваря файла за четене т.е. ще четем от този файл
* `ofstream fo("filename")` - отваря файла за писане т.е. ще пишем в този файл

Като втори аргумент при отварянето на файл се подават флагове, които определят в какъв режим да се отвори файла:
* `ios::in` - отваря файла за четене
* `ios::out` - отваря файла за писане
* `ios::binary` - операциите се изпълняват в двоичен режим вместо в текстов
* `ios::ate` - след отварянето на файла позицията за писане се поставя в края на файла
* `ios::app` - след всяка операция позицията за писане се поставя в края на файла
* `ios::trunc` - изтрива съдържанието на файла
* Комбинираме флаговете с побитово или: `ios::out | ios::trunc`

### Затваряне на файл
* `myFileStream.close()` - затваря файл. След като е затворен можем да използваме същата променлива за да отворим друг файл `myFileStream.open("textFile.txt", ios::out | ios::app)`
* Въпреки това, че компилатора се сърди повече за липсваща `;` отколкото за незатворен файлов поток е хубаво след като приключим работа с даден файл да го затворим

## Изход на поток
### Неформатиран изход:
* `ostream& put(char)` - вмъква символ в поток. Пример: `fo.put('A')`
* `ostream& write(const char*, streamsize)` - вмъква streamsize на брой символи от подадения символен низ в потока. Използваме тази функция при работа с двоични файлове. Пример: `fo.write(buff, 10)`. Забележете, че първият аргумент е символен низ, т.е. ако искаме да запишем цял обект трябва да го конвертираме по следният начин `fo.write((char*)&object, sizeof(Object))`, където Object е някакъв клас а object е обект от този клас.
### Форматиран изход:
* `ostream& operator<<(ostream&, T)` - Пример: `fo<<buff`

## Вход от поток
### Неформатиран вход:
* `istream& get(char&)` - прочита един символ. Пример: `fi.get(c)`.
* `istream& get(char*,streamsize,char)` - прочита символи и ги записва в първия аргумент докато не се прочетът или `streamsize-1` на брой символи или не се намери третия аргумент. Пример: `fi.get(buff, 25, '\n')`. Забележка ако разделящият символ (третия аргумент) се срещне четенето спира но той не се извлича от потока т.е. при следващото четене първо той ще се прочете. 
* `istream& getline(char*,streamsize,char)` - работи като горната точка с разликата, че премахва разделящият символ от потока. Пример: `is.getline(buff, 25, '\n')`
* `streamsize gcount() const` - връща броя на извлечените символи от последната операция за неформатиран вход. Пример: `fi.gcount()`
* `istream& read(char*, streamsize)` - прочита `streamsize` на брой символи. Използваме тази функция при работа с двоични файлове. Пример: `fi.read(buff, 5)`. Забележете, че първият аргумент е символен низ, т.е. ако искаме да четем цял обект трябва да го конвертираме по следният начин `fi.read((char*)&object, sizeof(Object))`, където Object е някакъв клас а object е обект от този клас.
### Форматиран вход:
* `istream& operator>>(istream&, T&)` - Пример: `fi>>buff`

## Потокови манипулатори
* `iomanip` - името на библиотеката
* `stream << data1 << manipulator << data2` - примерен начин за използване
* Манипулатори за изход: `endl`, `ends`, `flush`
* Манипулатори за бройна система: `hex`, `oct`, `dec`
* Манипулатори за поле: `setw`, `setfill`, `left`, `right`, `internal`
* Манипулатори за дробни числа: `fixed`, `scientific`, `setprecision`
* Манипулатори за формат: `setiosflags`, `setbase`
* . . . и много други
[Прочетете за манипулаторите тук](http://www.cplusplus.com/reference/iomanip/)

## Пряк достъп до файлове
Селектори:
* `streampos tellg() const` - връща позицията на указателя за четене т.е. ако отворим файл и прочетем 6 символа ще върне 6, ако прочетем още 6 и извикаме пак функцията ще върне 12. Пример: `fi.tellg()`
* `streampos tellp() const` - връща позицията на указателя за писане. Пример: `fo.tellp()`

Мутатори:
* `istream& seekg(streampos, seekdir = beg)` - променя позицията на указателя за четене. Първият аргумент е цяло число (може и отрицателно) а вторият е позиция `ios::beg`, `ios::curr`, `ios::end` съответно за началото на файла, текущата позиция или края на файла. Пример: `seekg(42, ios::curr)` - премества укаателя за четене с 42 байта напред
* `ostream& seekp(streampos, seekdir = beg)` - променя позицията на указателя за писане. Пример: `seekp(-42, ios::end)` - поставя указателя за писане на 42 байта преди края на файла.
